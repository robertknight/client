import classnames from 'classnames';
import { createElement } from 'preact';
import { useEffect, useState, useMemo } from 'preact/hooks';
import propTypes from 'prop-types';

import { getBoundingClientRect } from '../highlighter';

/**
 * @typedef Anchor
 * @prop {Object} annotation
 * @prop {HTMLElement} highlights
 */

/**
 * @typedef Bucket
 * @prop {number} minYOffset
 * @prop {number} maxYOffset
 * @prop {'on-screen'|'above-screen'|'below-screen'} location -
 *   Location of this bucket's anchors relative to the viewport.
 * @prop {Anchor[]} anchors
 */

/**
 * @param {Bucket} a
 * @param {Bucket} b
 * @return {Bucket}
 */
function mergeBuckets(a, b) {
  return {
    minYOffset: Math.min(a.minYOffset, b.minYOffset),
    maxYOffset: Math.max(a.maxYOffset, b.maxYOffset),
    location: a.location,
    anchors: a.anchors.concat(b.anchors),
  };
}

/**
 * @param {Anchor} anchor
 * @return {Bucket}
 */
function bucketForAnchor(anchor, minOnScreenYOffset, maxOnScreenYOffset) {
  const rect = getBoundingClientRect(anchor.highlights);
  let location;
  if (rect.bottom < minOnScreenYOffset) {
    location = 'above-screen';
  } else if (rect.top > maxOnScreenYOffset) {
    location = 'below-screen';
  } else {
    location = 'on-screen';
  }

  return {
    minYOffset: rect.top,
    maxYOffset: rect.bottom,
    location,
    anchors: [anchor],
  };
}

/**
 * Build a set of buckets for use with the `BucketBar` component from a set
 * of anchors generated by anchoring logic.
 *
 * @param {Anchor[]} anchors
 * @param {number} scrollOffset - Vertical scroll offset of window
 * @param {number} scrollHeight - Vertical height of window
 * @return {Bucket[]}
 */
export function buildBuckets(anchors, minOnScreenYOffset, maxOnScreenYOffset) {
  // Put each anchor into a bucket based on its location relative to the
  // viewport.
  let aboveScreenBucket;
  let belowScreenBucket;
  const onScreenBuckets = [];

  for (let anchor of anchors) {
    const bucket = bucketForAnchor(
      anchor,
      minOnScreenYOffset,
      maxOnScreenYOffset
    );
    if (bucket.location === 'above-screen') {
      aboveScreenBucket = aboveScreenBucket
        ? mergeBuckets(aboveScreenBucket, bucket)
        : bucket;
    } else if (bucket.location === 'below-screen') {
      belowScreenBucket = belowScreenBucket
        ? mergeBuckets(belowScreenBucket, bucket)
        : bucket;
    } else {
      onScreenBuckets.push(bucket);
    }
  }

  // Minimum gap between anchors for them to be placed in separate buckets.
  const minBucketGap = 60;

  // Sort all the on-screen buckets by their Y offset and combine buckets that
  // are close together.
  onScreenBuckets.sort((a, b) => a.minYOffset - b.minYOffset);
  let i = 1;
  while (i < onScreenBuckets.length) {
    if (
      onScreenBuckets[i].minYOffset <
      onScreenBuckets[i - 1].maxYOffset + minBucketGap
    ) {
      onScreenBuckets[i - 1] = mergeBuckets(
        onScreenBuckets[i - 1],
        onScreenBuckets[i]
      );
      onScreenBuckets.splice(i, 1);
    } else {
      ++i;
    }
  }

  const buckets = [];
  if (aboveScreenBucket) {
    buckets.push(aboveScreenBucket);
  }
  buckets.push(...onScreenBuckets);
  if (belowScreenBucket) {
    buckets.push(belowScreenBucket);
  }
  return buckets;
}

/**
 * A tab on the bucket bar when represents a group of annotations that are
 * at (roughly) the same vertical location in the document.
 */
function BucketBarTab({ bucket, onClick, onMouseOver, onMouseOut, yOffset }) {
  const count = bucket.anchors.length;
  const label =
    count === 1 ? `Show one annotations` : `Show ${count} annotations`;

  return (
    <button
      aria-label={label}
      className={classnames(
        'annotator-bucket-indicator',
        bucket.location === 'above-screen' && 'upper',
        bucket.location === 'below-screen' && 'lower'
      )}
      onClick={onClick}
      onFocus={onMouseOver}
      onBlur={onMouseOut}
      onMouseOver={onMouseOver}
      onMouseOut={onMouseOut}
      title={label}
      style={{
        top: yOffset,
      }}
    >
      <div className="label">{count}</div>
    </button>
  );
}

BucketBarTab.propTypes = {
  bucket: propTypes.object,
  onClick: propTypes.func,
  onMouseOver: propTypes.func,
  onMouseOut: propTypes.func,
  yOffset: propTypes.number,
};

function getScrollOffset(container) {
  return container.scrollY || container.scrollTop;
}

function getScrollHeight(container) {
  return container.innerHeight || container.clientHeight;
}

/**
 * A toolbar that displays tabs indicating the locations of groups ("buckets")
 * of annotations within the document.
 *
 * Clicking on a tab selects the annotations, if they are on-screen or scrolls
 * them into view otherwise.
 */
export default function BucketBar({
  anchors,
  scrollContainer,

  focusAnchors,
  selectAnchors,
  scrollToAnchors,
}) {
  const [scrollOffset, setScrollOffset] = useState(() =>
    getScrollOffset(scrollContainer)
  );
  const [scrollHeight, setScrollHeight] = useState(() =>
    getScrollHeight(scrollContainer)
  );

  useEffect(() => {
    const updateScrollPos = () => {
      setScrollOffset(getScrollOffset(scrollContainer));
      setScrollHeight(getScrollHeight(scrollContainer));
    };
    window.addEventListener('resize', updateScrollPos);
    scrollContainer.addEventListener('scroll', updateScrollPos);

    return () => {
      scrollContainer.removeEventListener('scroll', updateScrollPos);
      window.removeEventListener('resize', updateScrollPos);
    };
  }, [scrollContainer]);

  const minOnScreenYOffset = 140;
  const maxOnScreenYOffset = scrollHeight - 20;

  const buckets = useMemo(() => {
    const anchorsWithHighlights = anchors.filter(
      a => Array.isArray(a.highlights) && a.highlights.length > 0
    );

    // Fake dependency to trigger rebuilding of buckets when window scroll
    // position changes.
    // eslint-disable-next-line no-unused-expressions
    scrollOffset;
    return buildBuckets(
      anchorsWithHighlights,
      minOnScreenYOffset,
      maxOnScreenYOffset
    );
  }, [anchors, minOnScreenYOffset, maxOnScreenYOffset, scrollOffset]);

  const onBucketClick = bucket => {
    if (bucket.location !== 'on-screen') {
      scrollToAnchors(bucket.anchors);
    } else {
      // TODO - Support multi-selection if `ctrlKey` or `metaKey` are pressed.
      selectAnchors(bucket.anchors);
    }
  };

  const yOffset = bucket => {
    let offset = (bucket.minYOffset + bucket.maxYOffset) / 2;
    offset = Math.max(minOnScreenYOffset, Math.min(offset, maxOnScreenYOffset));
    return offset;
  };

  return (
    <div className="annotator-bucket-bar">
      {buckets.map((bucket, i) => (
        // Support for keyboard focusing is handled in `BucketBarTab`.
        // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events
        <BucketBarTab
          key={i}
          bucket={bucket}
          onClick={() => onBucketClick(bucket)}
          onMouseOver={() => focusAnchors(bucket)}
          onMouseOut={() => focusAnchors(null)}
          yOffset={yOffset(bucket)}
        />
      ))}
    </div>
  );
}

BucketBar.propTypes = {
  /**
   * Anchors to generate and display buckets for.
   */
  anchors: propTypes.arrayOf(propTypes.object).isRequired,

  /**
   * Test seam. The window containing the anchors.
   */
  window_: propTypes.object,

  scrollContainer: propTypes.object,

  /**
   * Callback invoked when a user clicks on a bucket for on-screen anchors.
   */
  selectAnchors: propTypes.func,

  /** Callback invoked to scroll anchors into view. */
  scrollToAnchors: propTypes.func,

  /** Callback invoked when a user hovers or un-hovers a bucket. */
  focusAnchors: propTypes.func,
};
